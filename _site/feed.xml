<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Um tanto quanto curioso</description>
    <link>http://localhost:4000//</link>
    <atom:link href="http://localhost:4000//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 01 Dec 2020 15:17:48 -0300</pubDate>
    <lastBuildDate>Tue, 01 Dec 2020 15:17:48 -0300</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Automatizando tarefas com o WhatsApp</title>
        <description>&lt;p&gt;Heeeey, tudo bem contigo? Estou muito animado com essa dica de hoje, porque eu amo esse tipo de projeto. Espero que você curta essa &lt;strong&gt;experiência&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;splash projects&quot;&gt;
    &lt;div class=&quot;content&quot;&gt;
        &lt;span class=&quot;title&quot;&gt;Já manja de Node.js?&lt;/span&gt;
        &lt;span class=&quot;description&quot;&gt;Então talvez você prefira ir direto para o código do projeto.&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class=&quot;btn&quot;&gt;
        &lt;a href=&quot;https://github.com/pedroentringer/bot-whatsapp-services&quot; target=&quot;_blank&quot;&gt;Ver o Projeto&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/f2c98102-23ed-45b9-a60a-00f89b8dfe0c.jpeg&quot; style=&quot;width: 200px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Então vamos direto ao que interessa!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Recentemente uma turma lançou uma biblioteca simplesmente &lt;strong&gt;sensacional&lt;/strong&gt; que nos permite explorar &lt;strong&gt;demais&lt;/strong&gt; as funcionalidades do WhatsApp Web usando seu WebPack. A lib ficou incrivelmente profissional e simples de usar.&lt;/p&gt;

&lt;p&gt;O pacote chama-se &lt;strong&gt;whatsapp-web.js&lt;/strong&gt; e você pode conferir toda documentação &lt;a href=&quot;https://waguide.pedroslopez.me/&quot; title=&quot;whatsapp-web.js&quot;&gt;clicando aqui&lt;/a&gt;, e o github &lt;a href=&quot;https://github.com/pedroslopez/whatsapp-web.js&quot; title=&quot;whatsapp-web.js&quot;&gt;clicando aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h5 id=&quot;bora-codar&quot;&gt;Bora Codar&lt;/h5&gt;
&lt;p&gt;Já crie um projeto por ai, com essa estrutura:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/6f208174-0592-4142-a5f1-360e2f4b2554.png&quot; alt=&quot;Estrutura de Pastas&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;pacotes&quot;&gt;Pacotes&lt;/h6&gt;
&lt;p&gt;Neste projeto iremos utilizar os seguintes pacotes, então inicie seu projeto com a estrutura acima e instale os pacotes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sucrase&lt;/li&gt;
  &lt;li&gt;whatsapp-web.js&lt;/li&gt;
  &lt;li&gt;@pedroentringer/parser-command-line&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn init -y
$ yarn add sucrase whatsapp-web.js @pedroentringer/parser-command-line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como iremos utilizar o &lt;strong&gt;sucrase&lt;/strong&gt; aqui para poder escrever com import/export vamos criar um script de start no &lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;name&quot;: &quot;bot-whatsapp&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;sucrase-node src/index.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@pedroentringer/parser-command-line&quot;: &quot;^1.0.1&quot;,
    &quot;sucrase&quot;: &quot;^3.15.0&quot;,
    &quot;whatsapp-web.js&quot;: &quot;^1.6.0&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show, feito isso vamos para o nosso arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; dentro da pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; e já iniciar nosso bot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//importo o Client do pacote
import { Client } from 'whatsapp-web.js'

/**
 * Crio o client, e é aqui que ele irá abrir o navegador de forma oculta usando puppeteer
 *
 * Porem aqui eu quero poder ler o QRCode pelo navegador sempre que for a primeira execução
 * para que assim eu não precise fazer isso pelo terminal então eu passo o headless como false
 */
const client = new Client({
  puppeteer: {
    headless: false
  }
})

//Escuto o evento ready que é disparo quando o navegador abre o whatsapp corretamente
client.on('ready', () =&amp;gt; console.log('Client is ready!'))

//Escuto o evento message que é disparado quando o whatsapp recebe uma nova mensagem
client.on('message', message =&amp;gt; console.log(message))

//inicializo o client para que tudo comece a rodar
client.initialize()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show de bola, se você rodar isso já vai conseguir ver seu navegador abrindo. Dai você vai precisar scanear o QRCode para acessar o WhatsApp.
Feito isso, sempre que receber uma nova mensagem ela ira aparecer no seu terminal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E olha que irado&lt;/strong&gt;, você já consegue receber todas as mensagens direto no código, sensacional né? Faça você mesmo, rode esse comando no seu terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn start&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;executando-comandos&quot;&gt;Executando comandos&lt;/h3&gt;
&lt;p&gt;Esse sisteminha vai rodar em um Windows Server, então todos os meus comandos Shell aqui serão para Win. &lt;strong&gt;Mas não se preocupe&lt;/strong&gt;, você poderá usar outros comandos de acordo com seu servidor.&lt;/p&gt;

&lt;p&gt;O Node.js tem por padrão um carinha chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; que você pode importar do pacote &lt;code class=&quot;highlighter-rouge&quot;&gt;child_process&lt;/code&gt; e é exatamente ele que iremos usar para rodar nossos comandos. Nele você consegue executar scripts como se estivesse no terminal/cmd da sua máquina.&lt;/p&gt;

&lt;p&gt;Pra fazer isso vamos criar um arquivo chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Shell.js&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components&lt;/code&gt; dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//importo o exec do node
import { exec } from 'child_process'

//crio uma classe pra controlar todos os comandos
export default class Shell {

  /** 
   * Defino uma function chamada restart que irá reiniciar alguns serviços
   * Perceba que ela recebe os parametros que são tratados pela lib @pedroentringer/parser-command-line
   */
  async restart ({ commands, flags }) {
    for (const command of commands) {
      
      /**
        * Se o comando for igual a &quot;cte&quot; vou matar o serviço que está rodando atualmente e rodar ele novamente
        */
      if (command === 'cte') {
        this.executeCommands([
          'taskkill /f /im cmd.exe /fi &quot;windowtitle eq CTE&quot;',
          'taskkill /f /im apagt_cte_nfe.exe',
          'start &quot;&quot; &quot;C:\\Users\\pedro.iconex\\Desktop\\CTE.bat&quot;'
        ])
      }

      /**
        * Se o comando for igual a &quot;email&quot; vou parart as services responsáveis por isso e iniciá-las novamente
        */
      if (command === 'email') {
        await this.executeCommands([
          'net stop apiintegracaoemailxml.exe',
          'net start apiintegracaoemailxml.exe',
          'net stop apiintegracaoemailedi.exe',
          'net start apiintegracaoemailedi.exe'
        ])
      }
    }
  }

  async run ({ commands, flags }) {
    for (const command of commands) {
      /**
        * Se o comando for igual a &quot;cte&quot; eu executo um start &quot;C:\\Users\\pedro.iconex\\Desktop\\CTE.bat&quot; em meu CMD.
        */
      if (command === 'cte') {
        this.executeCommand('start &quot;&quot; &quot;C:\\Users\\pedro.iconex\\Desktop\\CTE.bat&quot;')
      }

      /**
        * Se o comando for igual a &quot;cte&quot; eu executo um start &quot;D:\\API_NODE\\util\\ajustes\\corrigeIBGE.js&quot; em meu CMD.
        */
      if (command === 'ibge') {
        await this.executeCommand('node &quot;D:\\API_NODE\\util\\ajustes\\corrigeIBGE.js&quot;')
      }

    }
  }

  /**
   * Essa função vai receber um array de comandos e executar um de cada vez.
   */
  async executeCommands (commands) {
    for (const command of commands) {
      await this.executeCommand(command)
    }
  }

  /**
   * Essa função recebe a string do comando e executa usando o &quot;exec&quot; do node
   */
  executeCommand (command) {
    return new Promise((resolve, reject) =&amp;gt; {
      exec(command, (error, stdout, stderr) =&amp;gt; {
        if (error) reject(error)
        if (stderr) reject(stderr)
        resolve('Success')
      })
    })
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uma outra coisa interessante desse &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; é que a variável &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt; retorna exatamente tudo que for imprimido no terminal, dai você pode tratar isso de alguma forma se for necessário.&lt;/p&gt;

&lt;p&gt;Show de bola, até aqui nós já recebemos as mensagem e temos a classe responsável por executar os comandos.&lt;/p&gt;

&lt;p&gt;Mas antes de utilizar, vamos criar alguns alertas pop-up em nosso bot para que fique mais fácil de entender o que está acontecendo quando ele estiver em segundo plano.&lt;/p&gt;

&lt;h3 id=&quot;criando-alertas&quot;&gt;Criando Alertas&lt;/h3&gt;
&lt;p&gt;Eu gosto de pensar que esses scripts precisam ser ocultos, então costumo exibir um alerta na tela quando o programa inicia com sucesso ou apresenta algum erro.&lt;/p&gt;

&lt;p&gt;Pra fazer isso vamos criar um arquivo chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Alert.js&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components&lt;/code&gt; dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import Shell from './Shell'
const shell = new Shell()

export default class Alert {
  static showAlert (title, message) {
    const { platform } = process
    if (platform === 'darwin') this.showAlertDarwin(title, message)
    if (platform === 'win32') this.showAlertWin(title, message)
  }

  static showAlertDarwin (title, message) {
    /**
     * Repare que iremos usar nossa classe Shell para executar um script no terminal
     * Esse script exibe um pop-up no MacOs
     */
    shell.executeCommand(`osascript -e 'display notification &quot;${message}&quot; with title &quot;${title}&quot;'`)
  }

  static showAlertWin (title, message) {
    /**
     * Repare que iremos usar nossa classe Shell para executar um script no terminal
     * Esse script exibe um pop-up no Windows
     */
    shell.executeCommand(`msg %username% &quot;${title} ${message}&quot;`)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show feito isso, nós já receberemos os alertas em pop-up sempre que o bot iniciar. Aqui eu só consegui testar com Mac e Win. Então provavelmente para o linux você precisará adaptar esse comando.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/6daa59c1-25a5-40b6-b157-f5d22e252a76.png&quot; alt=&quot;Estrutura de Pastas&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;gravando-sessão-do-whatsapp&quot;&gt;Gravando Sessão do WhatsApp&lt;/h3&gt;
&lt;p&gt;O problema que temos agora é que sempre que você inicia o bot é necessário ficando lendo aquele QRCode novamente. Isso é bem chato né? Imagine um &lt;strong&gt;shutdown&lt;/strong&gt; não programado do servidor, seu bot iria parar de funcionar e você nem saberia.&lt;/p&gt;

&lt;p&gt;O pessoal da lib pensou nisso, e nos permitem salvar a sessão gerada pelo WhatsApp, maravilhoso né?&lt;/p&gt;

&lt;p&gt;Pra fazer isso, vamos criar um arquivo chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Session.js&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components&lt;/code&gt;, esse arquivo será uma classe que controlar essa sessão.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//importo a lib &quot;fs&quot; do node que me permitira ler e gravar arquivos
import * as fs from 'fs'

//importo a função &quot;resolve&quot; da lib &quot;path&quot; pra poder resolver um diretório
import { resolve } from 'path'

//importo nosso alerta, pra disparar as mensagems de sucesso ou erro
import Alert from './Alert'

//resolvo o caminho que irei salvar a sessão
const sessionPath = resolve(__dirname, '..', 'config', 'session.json')

//crio a classe Session
export default class Session {

  //crio uma função para salvar o conteudo da sessão em JSON
  static save (session) {
    fs.writeFile(
      sessionPath,
      JSON.stringify(session),
      async (error) =&amp;gt; error &amp;amp;&amp;amp; Alert.showAlert('[BOT] Pedro Entringer', error.message)
    )
  }

  //crio uma função para ler o JSON da sessão
  static get () {
    if (fs.existsSync(sessionPath)) {
      return require(sessionPath)
    }

    return undefined
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pronto! Assim que vincularmos isso ao bot você vera que será criado um arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;session.json&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/config&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lembre-se de criar essa pasta&lt;/strong&gt;, se não o código não irá funcionar.&lt;/p&gt;

&lt;h3 id=&quot;criando-o-bot-de-fato&quot;&gt;Criando o Bot de Fato&lt;/h3&gt;
&lt;p&gt;Já temos tudo que é preciso para executar os comandos em nosso servidor, certo? &lt;strong&gt;Sim.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Já estamos recebendo as mensagens do WhatsApp, certo? &lt;strong&gt;Sim.&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;então-o-que-falta-agora&quot;&gt;Então o que falta agora?&lt;/h5&gt;
&lt;p&gt;Hehehe, agora precisamos entender a mensagem que está chegando do WhatsApp para saber qual comando vamos executar.&lt;/p&gt;

&lt;p&gt;E vamos fazer isso usando a lib &lt;code class=&quot;highlighter-rouge&quot;&gt;@pedroentringer/parser-command-line&lt;/code&gt; de forma bastante simples.&lt;/p&gt;

&lt;p&gt;Crie um arquivo chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Bot.js&lt;/code&gt; na pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//importo a lib para fazer um parse nas mensagens
import { parseString } from '@pedroentringer/parser-command-line'

//import nosso shell
import Shell from './Shell'

//inicio o shell
const shell = new Shell()

//crio uma classe bot
export default class Bot {

  /**
   * Defino seu construtor recebendo o client do WhatsApp 
   * para que eu possa responder as mensagems por aqui.
   */
  constructor (client) {
    this.client = client

    /**
     * Defino um contato, pois eu desejo que apenas ele possa me enviar mensagems.
     * Alias, este é o meu contato, mude para o seu aqui.
     */
    this.contact = '5527981670051@c.us'
  }

  //crio uma função para validar se quem está mandando a mensagem é o contato que definimos
  isAdmin (contact) {
    if (!this.client) throw new Error('Client is not ready!')

    if (contact !== this.contact) throw new Error('Client is not ready!')
  }

  /**
   * Essa função recebe a mensagem e quem enviou
   * body =&amp;gt; Mensagem
   * from =&amp;gt; Quem enviou
   */
  async parseMessage ({ body, from }) {
    
    //valido se quem enviou a mensagem é o nosso contato
    this.isAdmin(from)

    //faço o parse da mensagem
    const { bin, commands, flags } = parseString(body)

    //defino quais são os &quot;bins&quot; aceitos pelo bot
    const availlableBins = ['restart', 'run', 'commands']

    //valido os bins
    if (availlableBins.find(availlableBin =&amp;gt; availlableBin === bin)) {
      try {

        //direciono os comandos e as flags baseado no bin recebido
        if (bin === 'commands') await this.showCommands(from)
        if (bin === 'restart') await shell.restart({ commands, flags })
        if (bin === 'run') await shell.run({ commands, flags })

        //se tudo ocorrer corretamente, respondo com sucesso.
        if (bin !== 'commands') await this.client.sendMessage(from, '✅ Command successfully executed')
      } catch (err) {

        //se houver erro respondo com o detalhe do erro.
        await this.client.sendMessage(from, `⚠️ ${err.message}`)
      }
    } else {

      //Se não for um comando válido
      await this.client.sendMessage(from, '🙁 This is not a valid command.')
    }
  }

  //lista os comandos válidos
  async showCommands (from) {
    await this.client.sendMessage(from, '🚀 List of commands')
    await this.client.sendMessage(from, '*run [{programs}]*\nUsed to run some system services.\nAvailable: cte, sefaz, ibge and ie')
    await this.client.sendMessage(from, '*restart [{programs}]*\nUsed to restart some system services.\nAvailable: cte and email')
    await this.client.sendMessage(from, '*commands*\nUsed to list all accepted commands.')
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sensacional! Isso já é suficiente para nosso Bot funcionar &lt;strong&gt;perfeitamente&lt;/strong&gt;, vamos liga-lo?&lt;/p&gt;

&lt;h3 id=&quot;toque-final&quot;&gt;Toque final&lt;/h3&gt;
&lt;p&gt;Criamos todas nossas classes principais, só precisamos agora é vincular elas de fato com nosso &lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt; do bot.&lt;/p&gt;

&lt;p&gt;Para fazer isso, vamos modificar nosso arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt;, e faremos da seguinte forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { Client } from 'whatsapp-web.js'

//importo todas as noosas classes
import Bot from './components/Bot'
import Alert from './components/Alert'
import Session from './components/Session'

//crio o client
const client = new Client({
  puppeteer: {
    headless: !!Session.get() //aqui eu valido se existe uma sessao, para saber se eu devo exibir o navegado ou não
  },
  session: Session.get() //busco a sessão existente
})

//inicio o bot
const bot = new Bot(client)

//exibo o alerta quando o bot estiver pronto para usi
client.on('ready', () =&amp;gt; Alert.showAlert('[BOT] Pedro Entringer', 'Client is ready!'))

//salvo a sessão quando fizermos a primeira leitura do QRCode
client.on('authenticated', (session) =&amp;gt; Session.save(session))

//mando as mensagens recebidas para o nosso Bot
client.on('message', message =&amp;gt; bot.parseMessage(message))

//inicializo o client do WhatsApp Web
client.initialize()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana né? E você pode aplicar isso em diversas outras funcionalidades. Aqui não existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 12 May 2020 19:50:00 -0300</pubDate>
        <link>http://localhost:4000//nodejs/automatizando-tarefas-com-o-whatsapp/</link>
        <guid isPermaLink="true">http://localhost:4000//nodejs/automatizando-tarefas-com-o-whatsapp/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>Criando seu plugin para Google Chrome</title>
        <description>&lt;p&gt;Heeeey, já vimos que na internet tem vaaaarios tutoriais sobre este tema, não é mesmo?
Vamos pra mais um, só que dessa vez, sem &lt;strong&gt;pop-up&lt;/strong&gt; hahaha.&lt;/p&gt;

&lt;p&gt;Ah, e esse plugin vai funcionar no Google Chrome, Opera e no novo Edge.&lt;/p&gt;

&lt;p&gt;O que nós vamos fazer por aqui é explorar aquele menu que aparece nos sites quando clicamos com o botão direito do mouse. Iremos criar uma opção para compartilhar um texto selecionado com algum contato do &lt;strong&gt;WhatsApp&lt;/strong&gt; que for definido no script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/5d73b650-3a82-4487-b133-a66217e0a7a7.png&quot; alt=&quot;Menu do navegador&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lets-go-to-code&quot;&gt;Let’s go to code&lt;/h3&gt;
&lt;p&gt;Vamos iniciar nosso projeto com uma pasta em branco, e nela criaremos o primeiro arquivo chamado &lt;strong&gt;manifest.json&lt;/strong&gt;. Este arquivo contem todos os detalhes de nossa extensão e eu vou explicar os mais importantes agora.&lt;/p&gt;

&lt;p&gt;Vamos colocar nele essas configurações:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;background&quot;: {
    &quot;persistent&quot;: false,
    &quot;scripts&quot;: [&quot;src/index.js&quot;]
  },
  &quot;browser_action&quot;: {
    &quot;default_title&quot;: &quot;Compartilhamento do Pedro&quot;,
    &quot;default_icon&quot;: &quot;icon.png&quot;
  },
  &quot;icons&quot;: {
      &quot;128&quot;: &quot;icon.png&quot;,
      &quot;16&quot;: &quot;icon.png&quot;,
      &quot;32&quot;: &quot;icon.png&quot;,
      &quot;48&quot;: &quot;icon.png&quot;
  },
  &quot;description&quot;: &quot;Compartilhar frases e sites&quot;,
  &quot;manifest_version&quot;: 2,
  &quot;name&quot;: &quot;Compartilhamento do Pedro&quot;,
  &quot;permissions&quot;: [&quot;contextMenus&quot;],
  &quot;short_name&quot;: &quot;Compartilhamento do Pedro&quot;,
  &quot;version&quot;: &quot;0.1&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vamos ver melhor o que significa isso:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;background&lt;/strong&gt;: aqui ficam as configurações de segundo plano, ou seja, aquilo que vai acontecer por tras da tela.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;persist&lt;/strong&gt;: definimos que não vamos salvar nada, ou seja, não iremos persistir nenhum dado.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;scripts&lt;/strong&gt;: e aqui vem o principal, serão os nossos arquivos de javascript que irão manipular o menu.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;browser_action&lt;/strong&gt;: aqui ficam as configurações mais visuais como icone e titulo que irão aparecer no menu.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;permissions&lt;/strong&gt;: Este passo é muito importante, pois sempre precisaremos deixar claro as permissões que desejamos usar. E para o nosso tutorial precisaremos apenas do &lt;strong&gt;contextMenus&lt;/strong&gt;, mas você pode ver as outras &lt;a href=&quot;https://support.google.com/chrome/a/answer/7515036?hl=pt-BR&quot; title=&quot;Permissões de Aplicativos e Extensões&quot;&gt;clicando aqui&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Feito isso vamos colocar um icone na extensão né, e pode ser na raiz do projeto mesmo, no meu caso vou por minha foto de perfil hahahah.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lembre-se&lt;/strong&gt; de colocar o arquivo com o mesmo nome e extensão que foi inserido no &lt;strong&gt;manifest.json&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;cadê-o-código&quot;&gt;Cadê o código?&lt;/h4&gt;
&lt;p&gt;kkkk eu sei, eu sei. Falei demais. &lt;strong&gt;bora codar&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Crie uma pasta &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt; e um &lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt; nela e vamos entender duas coisas. A instalação e as funcionalidades.&lt;/p&gt;

&lt;h5 id=&quot;instalação&quot;&gt;Instalação&lt;/h5&gt;
&lt;p&gt;Sempre que você instala uma extensão o chrome vai executar uma função chamada &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.runtime.onInstalled&lt;/code&gt;. E é essa função que iremos usar para criarmos os nossos menus.&lt;/p&gt;

&lt;p&gt;Pra começar vamos definir quais serão os nossos menus, dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
  {
    id: 'numero01',
    title: 'Compartilhar com a pessoa 01'
  },
  {
    id: 'numero02',
    title: 'Compartilhar com a pessoa 02'
  }
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show, agora vamos entender como vai funcionar esse onInstalled do chrome.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onInstalled = () =&amp;gt; {
  //essa função vai executar sempre que a extensão for instalada
}

chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bom, se já temos uma função que vai ser executada logo de inicio, é nela que iremos criar nossos menus. E vamos fazer isto usando uma outra função do chrome que é a &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.create&lt;/code&gt;, então vamos percorrer todos os nossos menus e cria-los.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
  {
    id: 'numero01',
    title: 'Compartilhar com a pessoa 01'
  },
  {
    id: 'numero02',
    title: 'Compartilhar com a pessoa 02'
  }
];

const onInstalled = () =&amp;gt; {

  for (const menu of menus) {

    chrome.contextMenus.create({ 
      ...menu, 
      contexts: ['selection'], 
    })
        
  }

}

chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reparou que o &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.create&lt;/code&gt; recebe um &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; como parâmetro? É isso que são os menus do chrome hehehe.&lt;/p&gt;

&lt;p&gt;Nós ainda passamos um array de &lt;strong&gt;contexts&lt;/strong&gt; pra essa função, e pra que isso server? É aqui onde definimos quando o menu aparece. Usando o context &lt;strong&gt;selection&lt;/strong&gt; estamos dizendo que o menu vai aparecer sempre que selecionarmos um texto em algum site e clicarmos com o botão direito.&lt;/p&gt;

&lt;p&gt;Você pode ver todos os contexts permitidos &lt;a href=&quot;https://developer.chrome.com/apps/contextMenus#type-ContextType&quot; title=&quot;Contexts&quot;&gt;clicando aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se testarmos essa extensão agora, já vamos conseguir ver nossos menus por lá:
&lt;img src=&quot;/assets/images/posts/12028790-eb93-4015-aaee-252a8bf74dc8.png&quot; alt=&quot;Menu do navegador com as nossas opções&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;funcionalidade&quot;&gt;Funcionalidade&lt;/h5&gt;
&lt;p&gt;Shoooow, já chegamos até aqui! Agora é mole demais!&lt;/p&gt;

&lt;p&gt;Pra adicionar funcionalidade ao clique em nosso menu iremos usar a outra função do chrome que é a &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.contextMenus.onClicked&lt;/code&gt; e o nosso código vai ficar mais ou menos assim:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onClicked = (data, tab) =&amp;gt; {
    const { menuItemId, selectionText} = data
    alert(`Selecionou o texto &quot;${selectionText}&quot; para compartilhar com &quot;${menuItemId}&quot;`)
}

chrome.contextMenus.onClicked.addListener(onClicked)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora sempre que selecionarmos um texto e usarmos nosso compartilhamento o navegador vai mostrar isso em um alerta hehehe
&lt;img src=&quot;/assets/images/posts/e7e74506-a182-4dc7-9983-96078f8cb539.png&quot; alt=&quot;Menu do navegador com as nossas opções&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mas é só isso?&lt;/strong&gt; kkkkkk Calma. Vamos de fato compartilhar o texto!&lt;/p&gt;

&lt;p&gt;Então agora é simples, já temos o texto e o numero da pessoa, então é só fazer o redirect pra url do &lt;strong&gt;WhatsApp&lt;/strong&gt; usando outro recurso do chrome chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.tabs.create&lt;/code&gt; que irá criar uma aba no navegador com a url que passarmos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const onClicked = (data, tab) =&amp;gt; {
    
    const { menuItemId, selectionText} = data
    
    const resource = new URL(&quot;https://api.whatsapp.com/send&quot;)
    resource.searchParams.append('phone', menuItemId)
    resource.searchParams.append('text', selectionText)

    chrome.tabs.create({ url: resource.href })

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E se você fez tudo certinho seu plugin já estará funcionando perfeitamente!!!&lt;/p&gt;

&lt;p&gt;Claro que esse exemplo é bastante simples, e você provavelmente não irá usar para nada, mas o que vale é entender o funcionamento de extensões do chrome.&lt;/p&gt;

&lt;p&gt;Aqui no trabalho nós usamos uma extensão semelhante a essa pra poder consultar pedidos diretamente do e-mail sem precisar ficar abrindo o sistema toda vez. Ah, e a extensão foi criada dessa mesma forma.&lt;/p&gt;

&lt;p&gt;O código completo ficou assim:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const menus = [
    {
        id: 'pessoa-01',
        title: 'Compartilhar com a pessoa 01'
    },
    {
        id: 'pessoa-02',
        title: 'Compartilhar com a pessoa 02'
    }
];
  
const onInstalled = () =&amp;gt; {

    for (const menu of menus) {

        chrome.contextMenus.create({ 
        ...menu, 
        contexts: ['selection'], 
        })
            
    }

}

const onClicked = (data, tab) =&amp;gt; {

    const { menuItemId, selectionText} = data
    
    const resource = new URL(&quot;https://api.whatsapp.com/send&quot;)
    resource.searchParams.append('phone', menuItemId)
    resource.searchParams.append('text', selectionText)

    chrome.tabs.create({ url: resource.href })

}

chrome.contextMenus.onClicked.addListener(onClicked)
chrome.runtime.onInstalled.addListener(onInstalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana né? E você pode aplicar isso em diversas outras funcionalidades. Aqui não existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 01 May 2020 04:20:00 -0300</pubDate>
        <link>http://localhost:4000//nodejs/criando-seu-plugin-para-google-chrome/</link>
        <guid isPermaLink="true">http://localhost:4000//nodejs/criando-seu-plugin-para-google-chrome/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>Trabalhando com argumentos em Node.js</title>
        <description>&lt;p&gt;Você já fez aquele programa que executa uma tarefa específica e que funciona perfeitamente, dai de repente surge a necessidade de que esse programa receba um parâmetro ao iniciar? &lt;strong&gt;Provavelmente sim&lt;/strong&gt;, mas caso ainda não tenha passado por isso, vale a pena aprender pois uma hora você irá acontecer.&lt;/p&gt;

&lt;p&gt;Vamos supor que ele precise receber um CNPJ no início do programa, por algum motivo do destino, talvez pra buscar os dados em alguma API. O que importa agora pra gente é entender como usar os argumentos.&lt;/p&gt;

&lt;p&gt;Naturalmente o Node.js nos permite acessar argumentos no início do programa, então vamos supor que eu deseje passar dois parâmetros, sendo eles &lt;strong&gt;cnpj&lt;/strong&gt; e &lt;strong&gt;isActive&lt;/strong&gt;, eu faria dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ node index 123 true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E lá no código, eu precisaria acessar esses parâmetros da seguinte maneira:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const cnpj = process.argv[2]
const isActive = Boolean(process.argv[3])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Funciona&lt;/strong&gt;? Sim, funciona. Mas você percebe que tanto a forma de passar esses argumentos quanto a de recebe-los ficou estranha? Talvez não agora, mas no futuro certamente irá ser. Imagine uma outra equipe dando manutenção nesse código dois anos depois.&lt;/p&gt;

&lt;p&gt;Pois é, eu passei por isso a um tempo atrás, e por este motivo fiz a lib &lt;strong&gt;@pedroentringer/parser-command-line&lt;/strong&gt; que simplifica muito este processo.&lt;/p&gt;

&lt;p&gt;Então vamos instalar esse trem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn add @pedroentringer/parser-command-line&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sensacional, feito isso já podemos passar e receber argumento de uma forma muito mais simples.
Usando o mesmo exemplo ficaria dessa forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ node index --cnpj=123 -isActive&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Melhorou né? Agora veja como faremos pra acessar isso no código:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const parser = require('@pedroentringer/parser-command-line')
const args = parser.parseArgs();

console.log(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que tanto a chamada do script quanto sua escrita ficaram muito mais simples né? Eis o resultado disso:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  bin: &quot;node&quot;,
  commands: [&quot;index&quot;],
  flags: {
    cnpj: 123,
    isActive: true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dessa forma fica muito melhor pra gente usar estes dados não é mesmo? E melhor ainda, você pode usar essa lib na web também, dessa forma é possível fazer o parse de um comando vindo de uma string. Pense que a ordem veio via websocket do backend, ou qualquer outro cenário hehehe.&lt;/p&gt;

&lt;p&gt;Usaríamos assim:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const parser = require('@pedroentringer/parser-command-line')
const args = parser.parseString('meuPrograma show --message=&quot;Que legal, isso é uma mensagem&quot; --time=100 -isSuccess');

console.log(args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;e o resultado desse parse será:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  bin: &quot;meuPrograma&quot;,
  commands: [&quot;show&quot;],
  flags: {
    message: &quot;Que legal, isso é uma mensagem&quot;,
    time: 100,
    isSuccess: true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana né? E você pode aplicar isso em diversas outras funcionalidades. Aqui não existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Apr 2020 10:00:00 -0300</pubDate>
        <link>http://localhost:4000//nodejs/trabalhando-com-argumentos-em-nodejs/</link>
        <guid isPermaLink="true">http://localhost:4000//nodejs/trabalhando-com-argumentos-em-nodejs/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
      <item>
        <title>Manipulando dados de um site com Web Scraping</title>
        <description>&lt;p&gt;É impressionante a ideia de conseguir manipular os dados de um site de outra pessoa não é mesmo? Eu adoro isso, logo quando comecei a faculdade de programação fiquei intrigado por não ser a primeira coisa a aprender (que sonho).&lt;/p&gt;

&lt;p&gt;Mas vamos direto ao ponto, aqui vamos aplicar o Web Scraping em um site simples e em outro um pouco mais complexo. &lt;strong&gt;Let`s go to code&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;bibliotecas-utilizadas&quot;&gt;Bibliotecas utilizadas:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Cheerio&lt;/li&gt;
  &lt;li&gt;@pedroentringer/cheerio-table-parser &lt;strong&gt;(Mágica kkk)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Axios&lt;/li&gt;
  &lt;li&gt;Puppeteer&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;manipulando-dados-de-um-sitesimples&quot;&gt;Manipulando dados de um site simples&lt;/h4&gt;
&lt;p&gt;Pra começar vamos criar nosso projeto bem rapidinho&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn init -y
$ yarn add cheerio axios puppeteer @pedroentringer/cheerio-table-parser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este processo pode demorar alguns minutinhos para terminar, enquanto isso vamos falar um pouco sobre cada uma dessas dependências.&lt;/p&gt;

&lt;h5 id=&quot;axios&quot;&gt;Axios&lt;/h5&gt;
&lt;p&gt;O Axios é muuuito usado para fazer requisições HTTP, quando você quer buscar ou enviar dados para algum site.
Por aqui vamos usar ele para buscar a estrutura do meu próprio blog hehehe&lt;/p&gt;

&lt;h5 id=&quot;cheerio&quot;&gt;Cheerio&lt;/h5&gt;
&lt;p&gt;O Cheerio é uma lib que nos permite manipular a DOM do site com mais facilidade, muito similar com a forma do JQuery.&lt;/p&gt;

&lt;h5 id=&quot;pedroentringercheerio-table-parser&quot;&gt;@pedroentringer/cheerio-table-parser&lt;/h5&gt;
&lt;p&gt;Essa é uma lib que eu mesmo fiz pra resolver uma problema que eu tive recentemente. Ela basicamente recebe qualquer tabela em HTML e converte para JSON, assim fica mais fácil de manipular os dados né? hehehe&lt;/p&gt;

&lt;h5 id=&quot;puppeteer&quot;&gt;Puppeteer&lt;/h5&gt;
&lt;p&gt;O Puppeteer é incrível, com ele você consegue mapear ações para que um “bot” replique no site usando um navegador, como se fosse uma pessoa de verdade, &lt;strong&gt;top né?&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;lets-go-to-code&quot;&gt;Let’s go to code&lt;/h5&gt;
&lt;p&gt;Depois que tudo tiver instalado certinho, bora começar de uma forma simples.
O desafio vai ser buscar o titulo do primeiro post desse nosso blog aqui.&lt;/p&gt;

&lt;p&gt;Pra fazer isso vamos criar nosso primeiro arquivo &lt;strong&gt;index.js&lt;/strong&gt; e já importar o &lt;em&gt;axios&lt;/em&gt; e o &lt;em&gt;cheerio&lt;/em&gt; nele&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const axios = require('axios')
const cheerio = require('cheerio')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Show, feito isso já podemos usar o axios para fazer uma busca na home do nosso blog, e vamos fazer isso da seguinte forma:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const webscraping = async () =&amp;gt; {

  //Busco os dados no site, e aqui vou receber todo o HTML dele
  const { data } = await axios.get('https://pedroentringer.dev')

  //Importo isso para o cheerio
  const $ = cheerio.load(data)

  //Busco todos os elementos de link &quot;a&quot; que sejam filho de elementos que possuem a classe &quot;post-title&quot; 
  const posts = $('.post-title a')

  //Pego apenas o primeiro elemento
  const firstPost = posts.first()

  //E taraaaam, exibo o texto que tem nesse elemento
  console.log(firstPost.text())

}
webscraping()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E o resultado disso será:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Manipulando dados de um site com Web Scraping
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simples né? Agora vamos complicar um pouco mais.&lt;/p&gt;

&lt;h4 id=&quot;manipulando-dados-de-um-sitecom-autenticação-e-navegação&quot;&gt;Manipulando dados de um site com autenticação e navegação&lt;/h4&gt;
&lt;p&gt;Agora imagine um cenário que você precise fazer um projeto freelancer pra uma empresa que possui um e-commerce em Magento 1.9, eles precisam visualizar facilmente os 5 pedidos mais populares do site.&lt;/p&gt;

&lt;p&gt;Nesse caso, a cada pagina do painel é gerado um token diferente, e seria bem chato ficar adivinhando como ele gera esse token para que possamos reproduzir da mesma forma, né? Maaas, para resolver isso nós podemos acessar esses dados usando um navegador, e é ai que entra o puppeteer.&lt;/p&gt;

&lt;p&gt;Vamos lá, importaremos todas as libs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import cheerio from 'cheerio'
import parseTable from '@pedroentringer/cheerio-table-parser'
import puppeteer from 'puppeteer'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que substituímos o axios pelo puppeteer.
E agora é só abrir o navegador, acessar o site, e &lt;strong&gt;daaaale&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const webscraping = async () =&amp;gt; {

  //Com o puppeteer eu chamo um navegador
  const browser = await puppeteer.launch({
    headless: true //Aqui eu defino se quero que ele apareça ou não =&amp;gt; true (não aparece) | false (aparece)
  })

  try {

    //Crio uma nova aba no navegador
    const page = await browser.newPage()

    //Acesso a pagina de login do painel
    await page.goto('meu_site/admin')

    //Insiro meu email no input de login
    await page.type('input[id=username]', 'oi@pedroentringer.dev')

    //Insiro minha senha no input do login
    await page.type('input[id=login]', 'minha_senha')

    //Clico no botão de Entrar
    await page.click('input[type=submit]')

    /**
    *  Agora eu preciso aguardar o site carregar
    *  e o elemento com id #grid_tab_reviewed_products aparecer na tela
    *  
    *  No painel do Magento 1.9 esse elemento representa um botão que 
    *  irá carregar na tela uma tabela com os 5 produtos mais visitados no site
    *  
    *  Assim que ele aparecer eu clico nele
    */
    await page.waitForSelector('#grid_tab_reviewed_products', { visible: true, timeout: 0 })
    await page.click('#grid_tab_reviewed_products')

    /**
    * Apos o clique, preciso esperar nossa tabela aparecer, pois o Magento irá fazer um request e buscar esses dados
    */
    await page.waitForSelector('#productsReviewedGrid_table', { visible: true, timeout: 0 })

    /**
    * Perfeito, agora que chegamos aqui, é como se estivessemos naquele exemplo simples
    * Basta pegar o html da pagina e manipular com o cheerio
    */
    const html = await page.content()

    //Lembre-se sempre de fechar o navegador kkk
    await browser.close()

    //Importo o HTML do site atual para o cheerio
    const $ = cheerio.load(html)
    
    //Ativo o modulo de converter a tabela
    parseTable($)

    //converto a tabela para JSON
    const table = $('#productsReviewedGrid_table').parseTable()

    console.log(table)

  } catch (err) {
    await browser.close()
    console.error(err)
  }
}
webscraping()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O mais legal é o resultado super fácil de manipular, veja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
  {
    nome: 'Camiseta Infantil Ac/Dc Preta',
    preco: 'R$ 42,90',
    visitas: 185
  },
  {
    nome: 'Body Beatles Yellow Submarine Manga Curta Branco',
    preco: 'R$ 39,90',
    visitas: 178
  },
  {
    nome: 'Body Iron Maiden Manga Curta Preto Algodão',
    preco: 'R$ 39,90',
    visitas: 170
  },
  {
    nome: 'Body Manga Curta Chega De Nana Neném Preto',
    preco: 'R$ 39,90',
    visitas: 144
  },
  {
    nome: 'Body Ac/Dc Manga Curta Preto',
    preco: 'R$ 39,90',
    visitas: 141
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Super bacana né? E você pode aplicar isso em diversas outras funcionalidades. Aqui não existem limites. hehehe&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divirta-se!&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Apr 2020 15:30:00 -0300</pubDate>
        <link>http://localhost:4000//nodejs/manipulando-dados-de-um-site-com-web-scraping/</link>
        <guid isPermaLink="true">http://localhost:4000//nodejs/manipulando-dados-de-um-site-com-web-scraping/</guid>
        
        
        <category>Nodejs</category>
        
      </item>
    
  </channel>
</rss>
